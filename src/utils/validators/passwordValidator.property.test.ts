/**
 * Property-based tests for password validation.
 *
 * **Property 2: Password Validation Correctness**
 * For any string input, the password validator SHALL accept it if and only if
 * it contains at least 8 characters AND at least 1 numeric digit.
 *
 * **Validates: Requirements 1.3**
 *
 * Tag: Feature: core-auth, Property 2: Password Validation Correctness
 *
 * @module utils/validators/passwordValidator.property.test
 */

import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import { validatePassword } from './passwordValidator.js';
import {
  validPasswordArb,
  tooShortPasswordArb,
  noDigitPasswordArb,
} from '../../test/arbitraries.js';

describe('Property 2: Password Validation Correctness', () => {
  /**
   * **Validates: Requirements 1.3**
   *
   * For any password generated by the validPasswordArb arbitrary (which produces
   * strings with at least 8 characters AND at least 1 digit), the validator
   * SHALL accept it.
   */
  it('should accept all valid passwords (>= 8 chars with at least 1 digit)', () => {
    fc.assert(
      fc.property(validPasswordArb, (password) => {
        const result = validatePassword(password);
        expect(result.valid).toBe(true);
        expect(result.errors).toEqual([]);
      }),
      {
        numRuns: 100,
        verbose: true,
      },
    );
  });

  /**
   * **Validates: Requirements 1.3**
   *
   * For any password generated by the tooShortPasswordArb arbitrary (which
   * produces strings with fewer than 8 characters), the validator SHALL
   * reject it.
   */
  it('should reject all passwords that are too short (< 8 chars)', () => {
    fc.assert(
      fc.property(tooShortPasswordArb, (password) => {
        const result = validatePassword(password);
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
      }),
      {
        numRuns: 100,
        verbose: true,
      },
    );
  });

  /**
   * **Validates: Requirements 1.3**
   *
   * For any password generated by the noDigitPasswordArb arbitrary (which
   * produces strings with at least 8 characters but no numeric digits),
   * the validator SHALL reject it.
   */
  it('should reject all passwords with no digits (>= 8 chars, no number)', () => {
    fc.assert(
      fc.property(noDigitPasswordArb, (password) => {
        const result = validatePassword(password);
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
        // Specifically, the error should mention the missing number
        expect(result.errors.some((e) => e.includes('number'))).toBe(true);
      }),
      {
        numRuns: 100,
        verbose: true,
      },
    );
  });

  /**
   * **Validates: Requirements 1.3**
   *
   * For any valid password, the result SHALL always have the correct shape:
   * { valid: true, errors: [] }
   */
  it('should return consistent ValidationResult shape for valid passwords', () => {
    fc.assert(
      fc.property(validPasswordArb, (password) => {
        const result = validatePassword(password);
        expect(result).toHaveProperty('valid');
        expect(result).toHaveProperty('errors');
        expect(typeof result.valid).toBe('boolean');
        expect(Array.isArray(result.errors)).toBe(true);
        if (result.valid) {
          expect(result.errors).toEqual([]);
        }
      }),
      {
        numRuns: 100,
      },
    );
  });

  /**
   * **Validates: Requirements 1.3**
   *
   * For any invalid password (too short or no digit), the result SHALL always
   * have the correct shape: { valid: false, errors: [<non-empty>] }
   */
  it('should return consistent ValidationResult shape for invalid passwords', () => {
    const invalidPasswordArb = fc.oneof(tooShortPasswordArb, noDigitPasswordArb);

    fc.assert(
      fc.property(invalidPasswordArb, (password) => {
        const result = validatePassword(password);
        expect(result).toHaveProperty('valid');
        expect(result).toHaveProperty('errors');
        expect(typeof result.valid).toBe('boolean');
        expect(Array.isArray(result.errors)).toBe(true);
        if (!result.valid) {
          expect(result.errors.length).toBeGreaterThan(0);
          for (const error of result.errors) {
            expect(typeof error).toBe('string');
            expect(error.length).toBeGreaterThan(0);
          }
        }
      }),
      {
        numRuns: 100,
      },
    );
  });
});
