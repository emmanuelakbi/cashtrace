/**
 * Property-based tests for email validation.
 *
 * **Property 1: Email Validation Correctness**
 * For any string input, the email validator SHALL accept it if and only if
 * it conforms to RFC 5322 email format standards.
 *
 * **Validates: Requirements 1.1**
 *
 * Tag: Feature: core-auth, Property 1: Email Validation Correctness
 *
 * @module utils/validators/emailValidator.property.test
 */

import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import { validateEmail } from './emailValidator.js';
import { validEmailArb, invalidEmailArb } from '../../test/arbitraries.js';

describe('Property 1: Email Validation Correctness', () => {
  /**
   * **Validates: Requirements 1.1**
   *
   * For any email generated by the validEmailArb arbitrary (which produces
   * RFC 5322 compliant email addresses), the validator SHALL accept it.
   */
  it('should accept all valid RFC 5322 email addresses', () => {
    fc.assert(
      fc.property(validEmailArb, (email) => {
        const result = validateEmail(email);
        expect(result.valid).toBe(true);
        expect(result.errors).toEqual([]);
      }),
      {
        numRuns: 100,
        verbose: true,
      },
    );
  });

  /**
   * **Validates: Requirements 1.1**
   *
   * For any string that is clearly not an email (no @ with domain structure),
   * the validator SHALL reject it.
   */
  it('should reject all clearly invalid strings', () => {
    fc.assert(
      fc.property(invalidEmailArb, (input) => {
        const result = validateEmail(input);
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
      }),
      {
        numRuns: 100,
        verbose: true,
      },
    );
  });

  /**
   * **Validates: Requirements 1.1**
   *
   * For any valid email, the result SHALL always have the correct shape:
   * { valid: true, errors: [] }
   */
  it('should return consistent ValidationResult shape for valid emails', () => {
    fc.assert(
      fc.property(validEmailArb, (email) => {
        const result = validateEmail(email);
        expect(result).toHaveProperty('valid');
        expect(result).toHaveProperty('errors');
        expect(typeof result.valid).toBe('boolean');
        expect(Array.isArray(result.errors)).toBe(true);
        if (result.valid) {
          expect(result.errors).toEqual([]);
        }
      }),
      {
        numRuns: 100,
      },
    );
  });

  /**
   * **Validates: Requirements 1.1**
   *
   * For any invalid input, the result SHALL always have the correct shape:
   * { valid: false, errors: [<non-empty>] }
   */
  it('should return consistent ValidationResult shape for invalid inputs', () => {
    fc.assert(
      fc.property(invalidEmailArb, (input) => {
        const result = validateEmail(input);
        expect(result).toHaveProperty('valid');
        expect(result).toHaveProperty('errors');
        expect(typeof result.valid).toBe('boolean');
        expect(Array.isArray(result.errors)).toBe(true);
        if (!result.valid) {
          expect(result.errors.length).toBeGreaterThan(0);
          for (const error of result.errors) {
            expect(typeof error).toBe('string');
            expect(error.length).toBeGreaterThan(0);
          }
        }
      }),
      {
        numRuns: 100,
      },
    );
  });
});
