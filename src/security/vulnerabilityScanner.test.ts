import { describe, it, expect, beforeEach } from 'vitest';
import { VulnerabilityScanner } from './vulnerabilityScanner.js';
import type { Dependency, KnownVulnerabilityEntry } from './types.js';

/** A small vulnerability database for testing. */
const testVulnDb: KnownVulnerabilityEntry[] = [
  {
    id: 'CVE-TEST-001',
    name: 'Critical vuln in pkg-a',
    severity: 'critical',
    affectedPackage: 'pkg-a',
    affectedVersions: ['1.0.0', '1.0.1'],
    fixVersion: '1.1.0',
    description: 'A critical test vulnerability.',
  },
  {
    id: 'CVE-TEST-002',
    name: 'High vuln in pkg-b',
    severity: 'high',
    affectedPackage: 'pkg-b',
    affectedVersions: ['2.0.0'],
    fixVersion: '2.0.1',
  },
  {
    id: 'CVE-TEST-003',
    name: 'Low vuln in pkg-c',
    severity: 'low',
    affectedPackage: 'pkg-c',
    affectedVersions: ['3.0.0', '3.0.1', '3.0.2'],
  },
];

const MS_PER_DAY = 24 * 60 * 60 * 1000;

function createScanner(options?: { intervalDays?: number; now?: Date }) {
  return new VulnerabilityScanner({
    vulnerabilityDb: testVulnDb,
    ...options,
  });
}

describe('VulnerabilityScanner', () => {
  const baseDate = new Date('2024-01-01T00:00:00Z');

  describe('constructor', () => {
    it('initializes with default weekly schedule', () => {
      const scanner = createScanner({ now: baseDate });
      const schedule = scanner.getSchedule();

      expect(schedule.lastScanAt).toBeNull();
      expect(schedule.nextScanAt).toEqual(baseDate);
      expect(schedule.intervalDays).toBe(7);
    });

    it('accepts a custom scan interval', () => {
      const scanner = createScanner({ intervalDays: 14, now: baseDate });
      const schedule = scanner.getSchedule();

      expect(schedule.intervalDays).toBe(14);
    });
  });

  describe('scan()', () => {
    let scanner: VulnerabilityScanner;

    beforeEach(() => {
      scanner = createScanner({ now: baseDate });
    });

    it('detects vulnerabilities in affected dependencies', () => {
      const deps: Dependency[] = [
        { name: 'pkg-a', version: '1.0.0' },
        { name: 'pkg-b', version: '2.0.0' },
      ];

      const result = scanner.scan(deps, baseDate);

      expect(result.dependenciesScanned).toBe(2);
      expect(result.vulnerabilitiesFound).toHaveLength(2);
      expect(result.vulnerabilitiesFound.map((v) => v.id)).toContain('CVE-TEST-001');
      expect(result.vulnerabilitiesFound.map((v) => v.id)).toContain('CVE-TEST-002');
    });

    it('returns no vulnerabilities for safe dependencies', () => {
      const deps: Dependency[] = [
        { name: 'pkg-a', version: '1.1.0' }, // fixed version
        { name: 'unknown-pkg', version: '1.0.0' },
      ];

      const result = scanner.scan(deps, baseDate);

      expect(result.dependenciesScanned).toBe(2);
      expect(result.vulnerabilitiesFound).toHaveLength(0);
    });

    it('records scan in history', () => {
      const deps: Dependency[] = [{ name: 'pkg-a', version: '1.0.0' }];

      scanner.scan(deps, baseDate);

      const history = scanner.getScanHistory();
      expect(history).toHaveLength(1);
      expect(history[0]!.scannedAt).toEqual(baseDate);
    });

    it('updates schedule after scan', () => {
      const deps: Dependency[] = [{ name: 'pkg-a', version: '1.0.0' }];

      scanner.scan(deps, baseDate);

      const schedule = scanner.getSchedule();
      expect(schedule.lastScanAt).toEqual(baseDate);
      expect(schedule.nextScanAt).toEqual(new Date(baseDate.getTime() + 7 * MS_PER_DAY));
    });

    it('does not duplicate vulnerabilities across multiple scans', () => {
      const deps: Dependency[] = [{ name: 'pkg-a', version: '1.0.0' }];

      scanner.scan(deps, baseDate);
      scanner.scan(deps, new Date(baseDate.getTime() + MS_PER_DAY));

      // Should still only have one vulnerability entry
      const vulns = scanner.getVulnerabilities();
      expect(vulns).toHaveLength(1);
      expect(vulns[0]!.id).toBe('CVE-TEST-001');
    });

    it('handles empty dependency list', () => {
      const result = scanner.scan([], baseDate);

      expect(result.dependenciesScanned).toBe(0);
      expect(result.vulnerabilitiesFound).toHaveLength(0);
    });

    it('sets detected vulnerabilities to open status', () => {
      const deps: Dependency[] = [{ name: 'pkg-c', version: '3.0.1' }];

      scanner.scan(deps, baseDate);

      const vulns = scanner.getVulnerabilities();
      expect(vulns).toHaveLength(1);
      expect(vulns[0]!.status).toBe('open');
    });

    it('populates fixVersion when available', () => {
      const deps: Dependency[] = [
        { name: 'pkg-a', version: '1.0.0' },
        { name: 'pkg-c', version: '3.0.0' },
      ];

      scanner.scan(deps, baseDate);

      const vulns = scanner.getVulnerabilities();
      const pkgA = vulns.find((v) => v.affectedPackage === 'pkg-a');
      const pkgC = vulns.find((v) => v.affectedPackage === 'pkg-c');

      expect(pkgA!.fixVersion).toBe('1.1.0');
      expect(pkgC!.fixVersion).toBeUndefined();
    });
  });

  describe('getVulnerabilities()', () => {
    it('returns all vulnerabilities when no filter is provided', () => {
      const scanner = createScanner({ now: baseDate });
      const deps: Dependency[] = [
        { name: 'pkg-a', version: '1.0.0' },
        { name: 'pkg-b', version: '2.0.0' },
      ];

      scanner.scan(deps, baseDate);

      expect(scanner.getVulnerabilities()).toHaveLength(2);
    });

    it('filters vulnerabilities by status', () => {
      const scanner = createScanner({ now: baseDate });
      const deps: Dependency[] = [
        { name: 'pkg-a', version: '1.0.0' },
        { name: 'pkg-b', version: '2.0.0' },
      ];

      scanner.scan(deps, baseDate);
      scanner.updateVulnerabilityStatus('CVE-TEST-001', 'pkg-a', '1.0.0', 'resolved');

      expect(scanner.getVulnerabilities('open')).toHaveLength(1);
      expect(scanner.getVulnerabilities('resolved')).toHaveLength(1);
      expect(scanner.getVulnerabilities('in_progress')).toHaveLength(0);
    });
  });

  describe('getScanHistory()', () => {
    it('returns empty array when no scans have been performed', () => {
      const scanner = createScanner({ now: baseDate });
      expect(scanner.getScanHistory()).toHaveLength(0);
    });

    it('returns scans in chronological order', () => {
      const scanner = createScanner({ now: baseDate });
      const deps: Dependency[] = [{ name: 'pkg-a', version: '1.0.0' }];

      const date1 = baseDate;
      const date2 = new Date(baseDate.getTime() + 7 * MS_PER_DAY);

      scanner.scan(deps, date1);
      scanner.scan(deps, date2);

      const history = scanner.getScanHistory();
      expect(history).toHaveLength(2);
      expect(history[0]!.scannedAt).toEqual(date1);
      expect(history[1]!.scannedAt).toEqual(date2);
    });
  });

  describe('isScanDue()', () => {
    it('returns true when no scan has been performed yet', () => {
      const scanner = createScanner({ now: baseDate });
      expect(scanner.isScanDue(baseDate)).toBe(true);
    });

    it('returns false immediately after a scan', () => {
      const scanner = createScanner({ now: baseDate });
      scanner.scan([], baseDate);

      const oneHourLater = new Date(baseDate.getTime() + 60 * 60 * 1000);
      expect(scanner.isScanDue(oneHourLater)).toBe(false);
    });

    it('returns true after the scan interval has elapsed', () => {
      const scanner = createScanner({ now: baseDate });
      scanner.scan([], baseDate);

      const eightDaysLater = new Date(baseDate.getTime() + 8 * MS_PER_DAY);
      expect(scanner.isScanDue(eightDaysLater)).toBe(true);
    });

    it('returns true exactly at the next scan time', () => {
      const scanner = createScanner({ now: baseDate });
      scanner.scan([], baseDate);

      const exactlySevenDays = new Date(baseDate.getTime() + 7 * MS_PER_DAY);
      expect(scanner.isScanDue(exactlySevenDays)).toBe(true);
    });

    it('respects custom interval', () => {
      const scanner = createScanner({ intervalDays: 14, now: baseDate });
      scanner.scan([], baseDate);

      const tenDaysLater = new Date(baseDate.getTime() + 10 * MS_PER_DAY);
      const fifteenDaysLater = new Date(baseDate.getTime() + 15 * MS_PER_DAY);

      expect(scanner.isScanDue(tenDaysLater)).toBe(false);
      expect(scanner.isScanDue(fifteenDaysLater)).toBe(true);
    });
  });

  describe('updateVulnerabilityStatus()', () => {
    it('updates the status of a tracked vulnerability', () => {
      const scanner = createScanner({ now: baseDate });
      scanner.scan([{ name: 'pkg-a', version: '1.0.0' }], baseDate);

      const updated = scanner.updateVulnerabilityStatus(
        'CVE-TEST-001',
        'pkg-a',
        '1.0.0',
        'in_progress',
      );

      expect(updated).toBeDefined();
      expect(updated!.status).toBe('in_progress');
    });

    it('returns undefined for unknown vulnerability', () => {
      const scanner = createScanner({ now: baseDate });

      const result = scanner.updateVulnerabilityStatus('CVE-UNKNOWN', 'pkg-x', '1.0.0', 'resolved');

      expect(result).toBeUndefined();
    });

    it('persists the status change', () => {
      const scanner = createScanner({ now: baseDate });
      scanner.scan([{ name: 'pkg-b', version: '2.0.0' }], baseDate);

      scanner.updateVulnerabilityStatus('CVE-TEST-002', 'pkg-b', '2.0.0', 'resolved');

      const vulns = scanner.getVulnerabilities('resolved');
      expect(vulns).toHaveLength(1);
      expect(vulns[0]!.id).toBe('CVE-TEST-002');
    });
  });
});
