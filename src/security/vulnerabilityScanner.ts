/**
 * Vulnerability Scanner for CashTrace Security & Compliance Module.
 *
 * Scans dependencies for known vulnerabilities using an in-memory
 * vulnerability database. Supports weekly scan scheduling and
 * scan history tracking.
 *
 * @module security/vulnerabilityScanner
 *
 * Requirement 9.1: Scan dependencies for known vulnerabilities weekly.
 */

import { randomUUID } from 'node:crypto';
import type {
  Dependency,
  KnownVulnerabilityEntry,
  ScanResult,
  ScanSchedule,
  Vulnerability,
  VulnerabilityStatus,
} from './types.js';

/** Default scan interval in days (weekly). */
const DEFAULT_SCAN_INTERVAL_DAYS = 7;

/** Milliseconds in one day. */
const MS_PER_DAY = 24 * 60 * 60 * 1000;

/**
 * Built-in known vulnerability database for simulation purposes.
 * In production this would be backed by a real advisory feed (e.g. OSV, NVD).
 */
const DEFAULT_VULNERABILITY_DB: KnownVulnerabilityEntry[] = [
  {
    id: 'CVE-2023-0001',
    name: 'Prototype Pollution in lodash',
    severity: 'critical',
    affectedPackage: 'lodash',
    affectedVersions: ['4.17.0', '4.17.1', '4.17.2', '4.17.3', '4.17.4'],
    fixVersion: '4.17.21',
    description: 'Prototype pollution vulnerability allowing arbitrary code execution.',
  },
  {
    id: 'CVE-2023-0002',
    name: 'ReDoS in minimatch',
    severity: 'high',
    affectedPackage: 'minimatch',
    affectedVersions: ['3.0.0', '3.0.1', '3.0.2', '3.0.3', '3.0.4'],
    fixVersion: '3.1.0',
    description: 'Regular expression denial of service.',
  },
  {
    id: 'CVE-2023-0003',
    name: 'Open Redirect in express',
    severity: 'medium',
    affectedPackage: 'express',
    affectedVersions: ['4.17.0', '4.17.1'],
    fixVersion: '4.17.3',
    description: 'Open redirect vulnerability in express.',
  },
  {
    id: 'CVE-2023-0004',
    name: 'Information Disclosure in axios',
    severity: 'low',
    affectedPackage: 'axios',
    affectedVersions: ['0.21.0', '0.21.1'],
    fixVersion: '0.21.2',
    description: 'Sensitive headers leaked on redirect.',
  },
];

export class VulnerabilityScanner {
  /** In-memory vulnerability database. */
  private readonly vulnerabilityDb: KnownVulnerabilityEntry[];

  /** Scan history, ordered by scan time. */
  private readonly scanHistory: ScanResult[] = [];

  /** All detected vulnerabilities keyed by id. */
  private readonly vulnerabilities = new Map<string, Vulnerability>();

  /** Scan schedule tracking. */
  private schedule: ScanSchedule;

  constructor(options?: {
    vulnerabilityDb?: KnownVulnerabilityEntry[];
    intervalDays?: number;
    now?: Date;
  }) {
    this.vulnerabilityDb = options?.vulnerabilityDb ?? DEFAULT_VULNERABILITY_DB;
    const intervalDays = options?.intervalDays ?? DEFAULT_SCAN_INTERVAL_DAYS;
    const now = options?.now ?? new Date();

    this.schedule = {
      lastScanAt: null,
      nextScanAt: now,
      intervalDays,
    };
  }

  /**
   * Scan a list of dependencies against the known vulnerability database.
   * Records the scan in history and updates the schedule.
   *
   * Requirement 9.1: Scan dependencies for known vulnerabilities.
   */
  scan(dependencies: Dependency[], now: Date = new Date()): ScanResult {
    const startTime = Date.now();
    const found: Vulnerability[] = [];

    for (const dep of dependencies) {
      const matches = this.vulnerabilityDb.filter(
        (entry) =>
          entry.affectedPackage === dep.name && entry.affectedVersions.includes(dep.version),
      );

      for (const match of matches) {
        // Avoid duplicating a vulnerability already tracked with same id + package + version
        const existingKey = `${match.id}:${dep.name}:${dep.version}`;
        const existing = [...this.vulnerabilities.values()].find(
          (v) => `${v.id}:${v.affectedPackage}:${v.version}` === existingKey,
        );

        if (existing) {
          found.push(existing);
        } else {
          const vuln: Vulnerability = {
            id: match.id,
            name: match.name,
            severity: match.severity,
            affectedPackage: dep.name,
            version: dep.version,
            fixVersion: match.fixVersion,
            detectedAt: now,
            status: 'open',
            description: match.description,
          };
          this.vulnerabilities.set(`${vuln.id}:${vuln.affectedPackage}:${vuln.version}`, vuln);
          found.push(vuln);
        }
      }
    }

    const duration = Date.now() - startTime;

    const result: ScanResult = {
      id: randomUUID(),
      scannedAt: now,
      dependenciesScanned: dependencies.length,
      vulnerabilitiesFound: found,
      duration,
    };

    this.scanHistory.push(result);

    // Update schedule
    this.schedule = {
      ...this.schedule,
      lastScanAt: now,
      nextScanAt: new Date(now.getTime() + this.schedule.intervalDays * MS_PER_DAY),
    };

    return result;
  }

  /**
   * Get all tracked vulnerabilities, optionally filtered by status.
   */
  getVulnerabilities(status?: VulnerabilityStatus): Vulnerability[] {
    const all = [...this.vulnerabilities.values()];
    if (status) {
      return all.filter((v) => v.status === status);
    }
    return all;
  }

  /**
   * Get the full scan history.
   */
  getScanHistory(): ReadonlyArray<ScanResult> {
    return [...this.scanHistory];
  }

  /**
   * Get the current scan schedule.
   */
  getSchedule(): ScanSchedule {
    return { ...this.schedule };
  }

  /**
   * Check whether a scan is due based on the weekly schedule.
   *
   * Requirement 9.1: Scan dependencies weekly.
   */
  isScanDue(now: Date = new Date()): boolean {
    return now >= this.schedule.nextScanAt;
  }

  /**
   * Update the status of a tracked vulnerability.
   * Returns the updated vulnerability, or undefined if not found.
   */
  updateVulnerabilityStatus(
    vulnerabilityId: string,
    affectedPackage: string,
    version: string,
    newStatus: VulnerabilityStatus,
  ): Vulnerability | undefined {
    const key = `${vulnerabilityId}:${affectedPackage}:${version}`;
    const vuln = this.vulnerabilities.get(key);
    if (!vuln) {
      return undefined;
    }
    const updated: Vulnerability = { ...vuln, status: newStatus };
    this.vulnerabilities.set(key, updated);
    return updated;
  }
}
