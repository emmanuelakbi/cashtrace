import { describe, it, expect, beforeEach } from 'vitest';
import { VulnerabilityAlertService } from './vulnerabilityAlertService.js';
import type { ScanResult, Vulnerability } from './types.js';

const MS_PER_HOUR = 60 * 60 * 1000;
const MS_PER_DAY = 24 * MS_PER_HOUR;

const baseDate = new Date('2024-06-01T00:00:00Z');

function makeVuln(overrides: Partial<Vulnerability> = {}): Vulnerability {
  return {
    id: 'CVE-2024-001',
    name: 'Critical RCE',
    severity: 'critical',
    affectedPackage: 'pkg-a',
    version: '1.0.0',
    fixVersion: '1.0.1',
    detectedAt: baseDate,
    status: 'open',
    ...overrides,
  };
}

function makeScanResult(vulns: Vulnerability[]): ScanResult {
  return {
    id: 'scan-1',
    scannedAt: baseDate,
    dependenciesScanned: vulns.length,
    vulnerabilitiesFound: vulns,
    duration: 100,
  };
}

describe('VulnerabilityAlertService', () => {
  let service: VulnerabilityAlertService;

  beforeEach(() => {
    service = new VulnerabilityAlertService();
  });

  // ─── Recipient Management ───

  describe('recipient management', () => {
    it('adds a recipient and returns it with an id', () => {
      const r = service.addRecipient('Alice', 'email', 'alice@example.com');

      expect(r.id).toBeDefined();
      expect(r.name).toBe('Alice');
      expect(r.channel).toBe('email');
      expect(r.destination).toBe('alice@example.com');
    });

    it('lists all recipients', () => {
      service.addRecipient('Alice', 'email', 'alice@example.com');
      service.addRecipient('Bob', 'sms', '+2341234567890');

      expect(service.getRecipients()).toHaveLength(2);
    });

    it('removes a recipient by id', () => {
      const r = service.addRecipient('Alice', 'email', 'alice@example.com');

      expect(service.removeRecipient(r.id)).toBe(true);
      expect(service.getRecipients()).toHaveLength(0);
    });

    it('returns false when removing a non-existent recipient', () => {
      expect(service.removeRecipient('no-such-id')).toBe(false);
    });
  });

  // ─── Alert Generation ───

  describe('processScanResults()', () => {
    it('generates alerts for critical vulnerabilities', () => {
      const scan = makeScanResult([makeVuln({ severity: 'critical' })]);
      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts).toHaveLength(1);
      expect(alerts[0]!.severity).toBe('critical');
      expect(alerts[0]!.status).toBe('pending');
    });

    it('generates alerts for high severity vulnerabilities', () => {
      const scan = makeScanResult([makeVuln({ id: 'CVE-HIGH', severity: 'high' })]);
      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts).toHaveLength(1);
      expect(alerts[0]!.severity).toBe('high');
    });

    it('does not generate alerts for medium severity', () => {
      const scan = makeScanResult([makeVuln({ id: 'CVE-MED', severity: 'medium' })]);
      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts).toHaveLength(0);
    });

    it('does not generate alerts for low severity', () => {
      const scan = makeScanResult([makeVuln({ id: 'CVE-LOW', severity: 'low' })]);
      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts).toHaveLength(0);
    });

    it('does not duplicate alerts for the same vulnerability', () => {
      const vuln = makeVuln();
      const scan1 = makeScanResult([vuln]);
      const scan2 = makeScanResult([vuln]);

      service.processScanResults(scan1, baseDate);
      const secondAlerts = service.processScanResults(scan2, baseDate);

      expect(secondAlerts).toHaveLength(0);
      expect(service.getAlerts()).toHaveLength(1);
    });

    it('generates separate alerts for different vulnerabilities', () => {
      const scan = makeScanResult([
        makeVuln({ id: 'CVE-A', severity: 'critical', affectedPackage: 'pkg-a' }),
        makeVuln({ id: 'CVE-B', severity: 'high', affectedPackage: 'pkg-b' }),
      ]);

      const alerts = service.processScanResults(scan, baseDate);
      expect(alerts).toHaveLength(2);
    });

    it('includes configured recipients in the alert', () => {
      const r = service.addRecipient('Alice', 'email', 'alice@example.com');
      const scan = makeScanResult([makeVuln()]);

      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts[0]!.recipientIds).toContain(r.id);
    });

    it('creates alert with descriptive message', () => {
      const scan = makeScanResult([makeVuln()]);
      const alerts = service.processScanResults(scan, baseDate);

      expect(alerts[0]!.message).toContain('CRITICAL');
      expect(alerts[0]!.message).toContain('pkg-a');
      expect(alerts[0]!.message).toContain('1.0.1'); // fix version
    });
  });

  // ─── Alert Status Management ───

  describe('alert status transitions', () => {
    it('marks an alert as sent', () => {
      const scan = makeScanResult([makeVuln()]);
      const [alert] = service.processScanResults(scan, baseDate);

      const sentTime = new Date(baseDate.getTime() + MS_PER_HOUR);
      const updated = service.markSent(alert!.id, sentTime);

      expect(updated!.status).toBe('sent');
      expect(updated!.sentAt).toEqual(sentTime);
    });

    it('marks an alert as acknowledged', () => {
      const scan = makeScanResult([makeVuln()]);
      const [alert] = service.processScanResults(scan, baseDate);

      const ackTime = new Date(baseDate.getTime() + 2 * MS_PER_HOUR);
      const updated = service.markAcknowledged(alert!.id, ackTime);

      expect(updated!.status).toBe('acknowledged');
      expect(updated!.acknowledgedAt).toEqual(ackTime);
    });

    it('returns undefined for unknown alert id on markSent', () => {
      expect(service.markSent('no-such-id')).toBeUndefined();
    });

    it('returns undefined for unknown alert id on markAcknowledged', () => {
      expect(service.markAcknowledged('no-such-id')).toBeUndefined();
    });
  });

  // ─── Alert Queries ───

  describe('getAlerts() and getPendingAlerts()', () => {
    it('returns all alerts when no filter is given', () => {
      const scan = makeScanResult([
        makeVuln({ id: 'CVE-1', affectedPackage: 'a' }),
        makeVuln({ id: 'CVE-2', affectedPackage: 'b' }),
      ]);
      service.processScanResults(scan, baseDate);

      expect(service.getAlerts()).toHaveLength(2);
    });

    it('filters alerts by status', () => {
      const scan = makeScanResult([
        makeVuln({ id: 'CVE-1', affectedPackage: 'a' }),
        makeVuln({ id: 'CVE-2', affectedPackage: 'b' }),
      ]);
      const alerts = service.processScanResults(scan, baseDate);
      service.markSent(alerts[0]!.id, baseDate);

      expect(service.getAlerts('pending')).toHaveLength(1);
      expect(service.getAlerts('sent')).toHaveLength(1);
    });

    it('getPendingAlerts returns only pending alerts', () => {
      const scan = makeScanResult([
        makeVuln({ id: 'CVE-1', affectedPackage: 'a' }),
        makeVuln({ id: 'CVE-2', affectedPackage: 'b' }),
      ]);
      const alerts = service.processScanResults(scan, baseDate);
      service.markSent(alerts[0]!.id, baseDate);

      const pending = service.getPendingAlerts();
      expect(pending).toHaveLength(1);
      expect(pending[0]!.vulnerabilityId).toBe('CVE-2');
    });

    it('returns empty array when no alerts exist', () => {
      expect(service.getAlerts()).toHaveLength(0);
      expect(service.getPendingAlerts()).toHaveLength(0);
    });
  });

  // ─── 24-Hour Deadline (Requirement 9.2) ───

  describe('isAlertWithinDeadline()', () => {
    it('returns true when alert is created at detection time', () => {
      const scan = makeScanResult([makeVuln({ detectedAt: baseDate })]);
      const [alert] = service.processScanResults(scan, baseDate);

      expect(service.isAlertWithinDeadline(alert!, baseDate)).toBe(true);
    });

    it('returns true when alert is created within 24 hours', () => {
      const detectedAt = baseDate;
      const alertTime = new Date(baseDate.getTime() + 23 * MS_PER_HOUR);
      const scan = makeScanResult([makeVuln({ detectedAt })]);
      const [alert] = service.processScanResults(scan, alertTime);

      expect(service.isAlertWithinDeadline(alert!, detectedAt)).toBe(true);
    });

    it('returns true when alert is created exactly at 24 hours', () => {
      const detectedAt = baseDate;
      const alertTime = new Date(baseDate.getTime() + MS_PER_DAY);
      const scan = makeScanResult([makeVuln({ detectedAt })]);
      const [alert] = service.processScanResults(scan, alertTime);

      expect(service.isAlertWithinDeadline(alert!, detectedAt)).toBe(true);
    });

    it('returns false when alert is created after 24 hours', () => {
      const detectedAt = baseDate;
      const alertTime = new Date(baseDate.getTime() + MS_PER_DAY + 1);
      const scan = makeScanResult([makeVuln({ detectedAt })]);
      const [alert] = service.processScanResults(scan, alertTime);

      expect(service.isAlertWithinDeadline(alert!, detectedAt)).toBe(false);
    });
  });
});
